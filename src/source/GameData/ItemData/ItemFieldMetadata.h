#pragma once

#ifdef _EDITOR

#include <Windows.h>
#include <string>
#include "ItemStructs.h"
#include "ItemFieldDefs.h"
#include "Translation/i18n.h"

// Helper to get translated field name with fallback
inline const char* GetFieldDisplayName(const char* fieldName)
{
    std::string translationKey = std::string("field_") + fieldName;
    if (i18n::HasTranslation(i18n::Domain::Metadata, translationKey.c_str()))
    {
        return i18n::TranslateMetadata(translationKey.c_str(), fieldName);
    }
    return fieldName;
}

// Type enum (kept minimal for type-based dispatch)
enum class EItemFieldType
{
    Bool,
    Byte,
    Word,
    Int,
    WCharArray
};

#define FIELD_OFFSET(type, field) offsetof(type, field)

// Simple field descriptor (replaces heavy ItemFieldMetadata struct)
struct FieldDescriptor
{
    const char* name;
    EItemFieldType type;
    size_t offset;
    float width;
};

// Macro to generate field descriptors
#define MAKE_SIMPLE_FIELD_DESCRIPTOR(name, type, arraySize, width) \
    { #name, EItemFieldType::type, FIELD_OFFSET(ITEM_ATTRIBUTE, name), width },

#define MAKE_ARRAY_FIELD_DESCRIPTOR(nameWithIndex, baseName, index, type, width) \
    { #nameWithIndex, EItemFieldType::type, FIELD_OFFSET(ITEM_ATTRIBUTE, baseName[index]), width },

// Internal: Single static array for all field descriptors (generated by X-macros)
namespace ItemFieldMetadataInternal
{
    static const FieldDescriptor s_descriptors[] = {
        { "Name", EItemFieldType::WCharArray, FIELD_OFFSET(ITEM_ATTRIBUTE, Name), 150.0f },
        ITEM_FIELDS_SIMPLE(MAKE_SIMPLE_FIELD_DESCRIPTOR)
        ITEM_FIELDS_ARRAYS(MAKE_ARRAY_FIELD_DESCRIPTOR)
    };
}

// Get pointer to field descriptor array
inline const FieldDescriptor* GetFieldDescriptors()
{
    return ItemFieldMetadataInternal::s_descriptors;
}

// Get count of fields (auto-computed from array size)
inline constexpr int GetFieldCount()
{
    return sizeof(ItemFieldMetadataInternal::s_descriptors) / sizeof(FieldDescriptor);
}

// Helper to render a field by descriptor
template<typename TColumns>
inline void RenderFieldByDescriptor(const FieldDescriptor& desc, TColumns* cols, ITEM_ATTRIBUTE& item,
                                     int& colIdx, int itemIndex, bool& rowInteracted, bool isVisible)
{
    if (!isVisible) return;

    BYTE* itemPtr = reinterpret_cast<BYTE*>(&item);
    void* fieldPtr = itemPtr + desc.offset;
    const char* displayName = GetFieldDisplayName(desc.name);

    // Generate unique ID
    int uniqueId = 0;
    for (const char* p = desc.name; *p; ++p) uniqueId = (uniqueId * 31) + *p;

    switch (desc.type)
    {
    case EItemFieldType::Bool:
        cols->RenderBoolColumn(displayName, colIdx, itemIndex, uniqueId, *reinterpret_cast<bool*>(fieldPtr), rowInteracted, isVisible);
        break;
    case EItemFieldType::Byte:
        cols->RenderByteColumn(displayName, colIdx, itemIndex, uniqueId, *reinterpret_cast<BYTE*>(fieldPtr), rowInteracted, isVisible);
        break;
    case EItemFieldType::Word:
        cols->RenderWordColumn(displayName, colIdx, itemIndex, uniqueId, *reinterpret_cast<WORD*>(fieldPtr), rowInteracted, isVisible);
        break;
    case EItemFieldType::Int:
        cols->RenderIntColumn(displayName, colIdx, itemIndex, uniqueId, *reinterpret_cast<int*>(fieldPtr), rowInteracted, isVisible);
        break;
    case EItemFieldType::WCharArray:
        cols->RenderWCharArrayColumn(displayName, colIdx, itemIndex, uniqueId, reinterpret_cast<wchar_t*>(fieldPtr), MAX_ITEM_NAME, rowInteracted, isVisible);
        break;
    }
}

#endif // _EDITOR
